# Read Master - Coding Standards

## Project Overview

This is an AI-powered reading comprehension platform built with a pnpm monorepo structure.

## Tech Stack

- **Frontend**: React 18 + TypeScript + Vite + Material-UI (MUI)
- **Backend**: Vercel Serverless Functions + TypeScript
- **Database**: Prisma ORM + Vercel Postgres
- **Cache**: Upstash Redis
- **Auth**: Clerk
- **AI**: Vercel AI SDK with Anthropic Claude
- **State**: React Query (server) + Zustand (client)

## Project Structure

```
apps/
  web/          # React frontend
    src/
      components/
        reader/      # Reading interface components
        library/     # Library management
        srs/         # Flashcard/SRS components
        social/      # Social features
        forum/       # Forum components
        common/      # Shared components (< 200 lines each)
        layout/      # Layout components
      pages/         # Route pages (< 300 lines each)
      hooks/         # Custom React hooks
      utils/         # Utility functions
      stores/        # Zustand stores
      locales/       # i18n translation files
  api/          # Vercel serverless functions
packages/
  database/     # Prisma ORM setup
  shared/       # Shared types and Zod schemas
  ai/           # Claude prompt templates
  config/       # ESLint, Prettier, TypeScript configs
```

## Coding Rules

### TypeScript

1. Always use TypeScript with strict mode enabled
2. Prefer `type` over `interface` unless extending
3. Use `unknown` over `any` - if `any` is necessary, add a comment explaining why
4. All function parameters and return types must be explicitly typed
5. Use `as const` assertions for literal types

### Modularity & Component Architecture

1. **File Size Limits**: Keep files focused and maintainable
   - Pages: Target **< 300 lines**, maximum 500 lines
   - Components: Target **< 200 lines**, maximum 300 lines
   - Utilities: Target **< 150 lines**, maximum 200 lines
   - If a file exceeds these limits, extract components or utilities

2. **Component Extraction**: Break down large components
   - Extract dialog/modal components to separate files
   - Extract repeated UI patterns (filters, lists, cards)
   - Extract view-specific components (ReaderView, LibraryView, etc.)
   - Create component folders for related components (e.g., `components/reader/`)

3. **Utility Extraction**: Keep logic separate
   - Extract filter/sort functions to `utils/` folder
   - Extract validation logic to separate files
   - Extract data transformation functions
   - Export types alongside utility functions

4. **Single Responsibility**: Each file should have one clear purpose
   - Pages orchestrate components and handle routing
   - Components render UI and handle user interaction
   - Hooks manage state and side effects
   - Utils provide pure functions for data manipulation

5. **Co-location**: Group related files together
   - Keep component-specific types in the same file or adjacent `.types.ts`
   - Keep component-specific hooks in a `hooks/` subfolder
   - Keep component-specific utils in a `utils/` subfolder

6. **Prefer Composition Over Large Files**
   - Build complex UIs by composing smaller components
   - Use children props and component composition patterns
   - Extract repeated JSX patterns into reusable components

### ESLint

1. Fix ESLint errors and warnings before committing rather than ignoring them with `// eslint-disable-next-line`.

### Imports

1. Use workspace imports: `@read-master/shared`, `@read-master/database`, `@read-master/ai`
2. Use path aliases: `@/components`, `@/lib`, `@/hooks`
3. Group imports: external, workspace, relative (with blank lines between)
4. Use type-only imports: `import type { User } from '@read-master/shared'`

### API & Validation

1. Use Zod for ALL API request/response validation
2. Define schemas in `packages/shared/src/schemas`
3. Never trust client input - always validate on the server
4. Return consistent error responses with proper HTTP status codes

### Database

1. All queries must handle soft deletes: `WHERE deletedAt IS NULL`
2. Store all dates in UTC
3. Use transactions for multi-table operations
4. Always use parameterized queries (Prisma handles this)

### State Management

1. Use React Query for all server state
2. Use Zustand for client-only state
3. Never use localStorage (serverless is stateless)
4. Invalidate queries after mutations

### AI Integration

1. Log all AI usage with tokens and cost in AIUsageLog table
2. Use prompt templates from `packages/ai/src/prompts`
3. Handle rate limits and retry with exponential backoff
4. Always stream responses for better UX
5. Respect user's AI preferences (can disable AI globally or per-book)

### Styling

1. Use MUI components exclusively
2. Use `sx` prop for component-specific styles
3. Use theme tokens for colors, spacing, typography
4. Support multiple themes: Light, Dark, Sepia, High Contrast
5. No inline styles or custom CSS unless absolutely necessary

### Logging & Errors

1. No `console.log` in committed code - use Winston logger
2. Create audit logs for all important entity changes
3. Handle errors gracefully with user-friendly messages
4. Log errors with context (userId, requestId, etc.)

### Testing

**CRITICAL: All development MUST include tests. Tests validate functionality, not the other way around.**

#### Test-First Development Principles

1. **ALL new features require tests** - No exceptions
   - New utility functions → Write tests first, then implementation
   - New API endpoints → Write tests to validate behavior
   - New components (when testable) → Write tests for critical logic
   - Bug fixes → Write a failing test first, then fix the bug

2. **Tests must validate ACTUAL functionality**
   - ❌ **NEVER** write tests that pass for non-functional code
   - ❌ **NEVER** mock away the actual logic being tested
   - ❌ **NEVER** write tests just to increase coverage numbers
   - ✅ Tests should fail when the feature is broken
   - ✅ Tests should pass only when the feature works correctly
   - ✅ If a test passes but the feature is broken, the test is wrong

3. **Fix features to pass tests, not tests to pass features**
   - When tests fail, fix the implementation (not the test)
   - When behavior changes, update tests to match new requirements
   - Tests are the source of truth for expected behavior

4. **Always run tests before considering work complete**

   ```bash
   # Frontend tests
   cd apps/web && pnpm vitest run

   # Backend tests (when applicable)
   cd apps/api && pnpm test
   ```

   - All tests must pass before committing
   - If tests fail, investigate and fix the root cause
   - Never commit with failing tests or disable tests to make CI pass

#### Testing Standards

1. **Use Vitest** for all frontend tests
2. **Test Coverage Requirements**:
   - **Utility functions**: 100% coverage (all functions must be tested)
   - **API routes**: Test all endpoints with various input scenarios
   - **Stores**: Test state management logic
   - **Critical business logic**: Minimum 80% coverage
   - **Reading algorithms** (SRS, progress tracking): 100% coverage
   - **Components**: Test critical rendering and interaction logic

3. **Test Quality Over Quantity**
   - Write meaningful assertions that validate actual behavior
   - Test edge cases and error conditions
   - Test integration between related functions
   - Use descriptive test names: `should calculate reading speed correctly`

4. **What to Test**:
   - ✅ All utility functions in `apps/web/src/utils/`
   - ✅ All Zustand stores in `apps/web/src/stores/`
   - ✅ SRS algorithm implementation
   - ✅ Reading progress calculations
   - ✅ Complex hooks with business logic
   - ✅ API endpoints and validation logic
   - ✅ Data transformation and filtering functions
   - ⚠️ Complex components (when feasible without excessive mocking)

5. **What NOT to Test**:
   - ❌ Third-party library internals (React Query, MUI, etc.)
   - ❌ Simple pass-through components with no logic
   - ❌ Type definitions alone (TypeScript handles this)

#### Test File Organization

- Place tests next to source files: `utils/srs.ts` → `utils/srs.test.ts`
- Export types and functions needed for testing
- Use `describe` blocks to group related tests
- Use `beforeEach` to reset state between tests

#### Pre-Commit Checklist

Before committing any code:

1. ✅ All new functions have tests
2. ✅ Run `pnpm vitest run` - all tests pass
3. ✅ Run `pnpm typecheck` - no type errors
4. ✅ Run `pnpm lint` - no linting errors
5. ✅ Manually verify feature works in browser/API
6. ✅ Update `PROGRESS.md` with completed work

### Git & Commits

1. Pre-commit hook runs: lint, format check, typecheck
2. No `console.log` statements allowed in commits
3. Use conventional commits: `feat:`, `fix:`, `chore:`, etc.
4. Keep PRs small and focused

#### CRITICAL: Commit Validation Rules

**NEVER use `--no-verify` to bypass pre-commit hooks unless explicitly instructed by the user.**

When a commit fails due to pre-commit hooks, you MUST:

1. **Fix all errors before attempting to commit again**:
   - ❌ **NEVER** use `git commit --no-verify` to bypass checks
   - ❌ **NEVER** disable or skip pre-commit hooks
   - ❌ **NEVER** commit with failing tests, lint errors, or type errors
   - ✅ Investigate and fix the root cause of each error
   - ✅ Re-run the commit only after all issues are resolved

2. **Error Resolution Priority**:
   - **Type errors**: Fix TypeScript errors in the code (run `pnpm typecheck` to verify)
   - **Lint errors**: Fix ESLint errors (run `pnpm lint` to verify)
   - **Test failures**: Fix failing tests (run `pnpm vitest run` to verify)
   - **Format issues**: Run `pnpm format` to auto-fix formatting

3. **If errors seem unrelated to your changes**:
   - Still fix them before committing
   - If the errors are in files you didn't modify, fix them anyway or notify the user
   - Pre-existing errors in the codebase should be fixed, not bypassed

4. **Only bypass hooks when explicitly told**:
   - The user must explicitly say "use --no-verify" or "skip pre-commit hooks"
   - Document why the bypass was necessary in the commit message
   - This should be extremely rare and only for exceptional circumstances

## File Naming Conventions

- Components: `PascalCase.tsx` (e.g., `ReaderView.tsx`)
- Component Folders: `camelCase/` for feature-specific components (e.g., `components/reader/`)
- Hooks: `camelCase.ts` with `use` prefix (e.g., `useReadingProgress.ts`)
- Utilities: `camelCase.ts` (e.g., `srsAlgorithm.ts`)
- Types: `camelCase.ts` or co-located in `.types.ts`
- Tests: `*.test.ts` or `*.spec.ts`
- Index files: Always include `index.ts` for clean exports from folders

## Documentation

### Core Documents (Root Directory)

- **[docs/SPECIFICATIONS.md](docs/SPECIFICATIONS.md)** - Product requirements and feature specifications
- **[PROGRESS.md](PROGRESS.md)** - Comprehensive progress tracking (update as you work)
- **[README.md](README.md)** - Project overview and getting started guide
- **[CLAUDE.md](CLAUDE.md)** - Detailed coding standards for AI assistants

### Before Starting Work

1. Review [PROGRESS.md](PROGRESS.md) for feature status
2. Review [docs/SPECIFICATIONS.md](docs/SPECIFICATIONS.md) for feature requirements
3. Check [CLAUDE.md](CLAUDE.md) for detailed coding standards
4. Reference the database schema in SPECIFICATIONS.md for data models

### After Completing Work

1. Ensure all tests pass (`pnpm vitest run`)
2. Verify linting and type checking pass
3. Test the feature manually
4. Update `PROGRESS.md` with completed work
5. Suggest new work in `PROGRESS.md` including high-impact, high-value features, and test coverage