# Read Master - Coding Standards

## Project Overview

This is an AI-powered reading comprehension platform built with a pnpm monorepo structure.

## ‚ö†Ô∏è CRITICAL: Cross-Platform Feature Parity

**EVERY feature MUST work across ALL platforms: Web, Desktop, and Mobile.**

### Platform Requirements

Read Master supports:
- üåê **Web**: Responsive browser app (React + Vite)
- üíª **Desktop**: Electron app (macOS, Windows, Linux)
- üì± **Mobile**: Native apps (iOS, Android)

### Mandatory Cross-Platform Rules

**When implementing ANY feature, you MUST:**

1. ‚úÖ **Implement for ALL three platforms** (Web, Desktop, Mobile)
   - Feature is NOT complete until it works everywhere
   - Test on all platforms before marking as done
   - Example: If you add annotations on web, you MUST add them on desktop and mobile too

2. ‚úÖ **Maintain UI/UX consistency**
   - Same core functionality on all platforms
   - Platform-appropriate interactions are OK (touch vs. mouse, gestures vs. keyboard)
   - Use responsive MUI components that adapt to all screen sizes

3. ‚úÖ **Data syncs automatically**
   - Books, progress, annotations, flashcards, settings sync in real-time
   - Backend API is platform-agnostic
   - Changes on one device appear immediately on all others

4. ‚úÖ **All platforms support offline mode**
   - PWA for web, local storage for desktop, native storage for mobile
   - Offline reading works everywhere
   - Auto-sync when back online

### Development Checklist for New Features

Before marking a feature as complete:

```
‚ñ° Implemented on web (responsive design)
‚ñ° Implemented on desktop (Electron)
‚ñ° Implemented on mobile (React Native/native)
‚ñ° Tested on all three platforms
‚ñ° Data syncs correctly between platforms
‚ñ° Works offline on all platforms
‚ñ° UI is consistent but platform-appropriate
‚ñ° Documentation updated to reflect cross-platform support
```

### Platform-Appropriate Adaptations (GOOD)

‚úÖ Same feature, different interaction method:
- **Desktop**: Right-click context menu for actions
- **Web**: Click button or dropdown for actions
- **Mobile**: Long-press menu for actions

‚úÖ Same feature, optimized layout:
- **Desktop**: Sidebar navigation
- **Web**: Responsive sidebar that collapses on mobile
- **Mobile**: Bottom navigation bar

### Platform Exclusivity (BAD - Do NOT do this)

‚ùå Feature only on one platform:
- Web has AI chat, but mobile doesn't
- Desktop has export, but web doesn't
- Mobile has gestures, but desktop has nothing

**If you can't implement it everywhere, escalate immediately. Default answer: Don't add it.**

## Tech Stack

- **Frontend**: React 18 + TypeScript + Vite + Material-UI (MUI)
- **Backend**: Vercel Serverless Functions + TypeScript
- **Database**: Prisma ORM + Vercel Postgres
- **Cache**: Upstash Redis
- **Auth**: Clerk
- **AI**: Vercel AI SDK with Anthropic Claude
- **State**: React Query (server) + Zustand (client)

## Project Structure

```
apps/
  web/          # React frontend
    src/
      components/
        reader/      # Reading interface components
        library/     # Library management
        srs/         # Flashcard/SRS components
        social/      # Social features
        forum/       # Forum components
        common/      # Shared components (< 200 lines each)
        layout/      # Layout components
      pages/         # Route pages (< 300 lines each)
      hooks/         # Custom React hooks
      utils/         # Utility functions
      stores/        # Zustand stores
      locales/       # i18n translation files
  api/          # Vercel serverless functions
packages/
  database/     # Prisma ORM setup
  shared/       # Shared types and Zod schemas
  ai/           # Claude prompt templates
  config/       # ESLint, Prettier, TypeScript configs
```

## Coding Rules

### TypeScript

1. Always use TypeScript with strict mode enabled
2. Prefer `type` over `interface` unless extending
3. **NEVER use `any` type in production code** - Use `unknown` instead and narrow the type
   - ‚ùå **FORBIDDEN**: `any` or `// eslint-disable-next-line @typescript-eslint/no-explicit-any` in production code
   - ‚úÖ **Exception**: Test files (`.test.ts`, `.spec.ts`) may use `any` when absolutely necessary for mocking or testing complex types
   - ‚úÖ **Better approach**: Even in tests, prefer `unknown` or proper typing when possible
   - If you must use `any` in a test file, add a comment explaining why it's unavoidable
4. All function parameters and return types must be explicitly typed
5. Use `as const` assertions for literal types

### Modularity & Component Architecture

1. **File Size Limits**: Keep files focused and maintainable
   - Pages: Target **< 300 lines**, maximum 500 lines
   - Components: Target **< 200 lines**, maximum 300 lines
   - Utilities: Target **< 150 lines**, maximum 200 lines
   - If a file exceeds these limits, extract components or utilities

2. **Component Extraction**: Break down large components
   - Extract dialog/modal components to separate files
   - Extract repeated UI patterns (filters, lists, cards)
   - Extract view-specific components (ReaderView, LibraryView, etc.)
   - Create component folders for related components (e.g., `components/reader/`)

3. **Utility Extraction**: Keep logic separate
   - Extract filter/sort functions to `utils/` folder
   - Extract validation logic to separate files
   - Extract data transformation functions
   - Export types alongside utility functions

4. **Single Responsibility**: Each file should have one clear purpose
   - Pages orchestrate components and handle routing
   - Components render UI and handle user interaction
   - Hooks manage state and side effects
   - Utils provide pure functions for data manipulation

5. **Co-location**: Group related files together
   - Keep component-specific types in the same file or adjacent `.types.ts`
   - Keep component-specific hooks in a `hooks/` subfolder
   - Keep component-specific utils in a `utils/` subfolder

6. **Prefer Composition Over Large Files**
   - Build complex UIs by composing smaller components
   - Use children props and component composition patterns
   - Extract repeated JSX patterns into reusable components

### ESLint

1. **NEVER use `// eslint-disable-next-line` to bypass linting errors** - Fix the underlying issue instead
   - ‚ùå **FORBIDDEN**: `// eslint-disable-next-line` in production code (especially `@typescript-eslint/no-explicit-any`)
   - ‚úÖ **Exception**: Test files may use `// eslint-disable-next-line` sparingly when testing error conditions or edge cases that intentionally violate rules
   - If you must disable a rule in a test file, add a comment explaining why it's necessary
   - When committing, all ESLint errors must be resolved by fixing the code, not by disabling the linter

### Imports

1. Use workspace imports: `@read-master/shared`, `@read-master/database`, `@read-master/ai`
2. Use path aliases: `@/components`, `@/lib`, `@/hooks`
3. Group imports: external, workspace, relative (with blank lines between)
4. Use type-only imports: `import type { User } from '@read-master/shared'`

### API & Validation

1. Use Zod for ALL API request/response validation
2. Define schemas in `packages/shared/src/schemas`
3. Never trust client input - always validate on the server
4. Return consistent error responses with proper HTTP status codes

### Database

1. All queries must handle soft deletes: `WHERE deletedAt IS NULL`
2. Store all dates in UTC
3. Use transactions for multi-table operations
4. Always use parameterized queries (Prisma handles this)
5. **CRITICAL: Always update seed data when modifying database schema**

#### Seed Data Requirements

**Location:** `packages/database/prisma/seed.ts`

**When schema changes, seed data MUST be updated:**

- **New model** ‚Üí Add 3-5 seed records with realistic data
- **New required field** ‚Üí Update ALL existing seed records
- **New enum** ‚Üí Include examples of all enum values
- **New relationship** ‚Üí Ensure related records exist
- **New constraints** ‚Üí Verify seed data respects them

**Seed data must include:**

- ‚úÖ Realistic data (not "test1", "test2")
- ‚úÖ Edge cases (nulls, boundaries, empty values)
- ‚úÖ All subscription tiers (Free, Pro, Scholar)
- ‚úÖ All user roles and permissions
- ‚úÖ Various record states (active, completed, deleted, etc.)
- ‚úÖ Full relationship chains (all foreign keys populated)

**Why:** Ensures development databases work immediately, tests have consistent data, new developers can start quickly, and edge cases are caught early.

**Enforcement:** Run `pnpm db:seed` after every schema change and verify it succeeds.

### State Management

1. Use React Query for all server state
2. Use Zustand for client-only state
3. Never use localStorage (serverless is stateless)
4. Invalidate queries after mutations

### AI Integration

1. Log all AI usage with tokens and cost in AIUsageLog table
2. Use prompt templates from `packages/ai/src/prompts`
3. Handle rate limits and retry with exponential backoff
4. Always stream responses for better UX
5. Respect user's AI preferences (can disable AI globally or per-book)

### Styling

1. Use MUI components exclusively
2. Use `sx` prop for component-specific styles
3. Use theme tokens for colors, spacing, typography
4. Support multiple themes: Light, Dark, Sepia, High Contrast
5. No inline styles or custom CSS unless absolutely necessary

### Logging & Errors

1. No `console.log` in committed code - use Winston logger
2. Create audit logs for all important entity changes
3. Handle errors gracefully with user-friendly messages
4. Log errors with context (userId, requestId, etc.)

### Testing

**CRITICAL: All development MUST include tests. Tests validate functionality, not the other way around.**

#### Test-First Development Principles

1. **ALL new features require tests** - No exceptions
   - New utility functions ‚Üí Write tests first, then implementation
   - New API endpoints ‚Üí Write tests to validate behavior
   - New components (when testable) ‚Üí Write tests for critical logic
   - Bug fixes ‚Üí Write a failing test first, then fix the bug

2. **Tests must validate ACTUAL functionality**
   - ‚ùå **NEVER** write tests that pass for non-functional code
   - ‚ùå **NEVER** mock away the actual logic being tested
   - ‚ùå **NEVER** write tests just to increase coverage numbers
   - ‚úÖ Tests should fail when the feature is broken
   - ‚úÖ Tests should pass only when the feature works correctly
   - ‚úÖ If a test passes but the feature is broken, the test is wrong

3. **Fix features to pass tests, not tests to pass features**
   - When tests fail, fix the implementation (not the test)
   - When behavior changes, update tests to match new requirements
   - Tests are the source of truth for expected behavior

4. **Always run tests before considering work complete**

   ```bash
   # Frontend tests
   cd apps/web && pnpm vitest run

   # Backend tests (when applicable)
   cd apps/api && pnpm test
   ```

   - All tests must pass before committing
   - If tests fail, investigate and fix the root cause
   - Never commit with failing tests or disable tests to make CI pass

#### Testing Standards

1. **Use Vitest** for all frontend tests
2. **Test Coverage Requirements**:
   - **Utility functions**: 100% coverage (all functions must be tested)
   - **API routes**: Test all endpoints with various input scenarios
   - **Stores**: Test state management logic
   - **Critical business logic**: Minimum 80% coverage
   - **Reading algorithms** (SRS, progress tracking): 100% coverage
   - **Components**: Test critical rendering and interaction logic

3. **Test Quality Over Quantity**
   - Write meaningful assertions that validate actual behavior
   - Test edge cases and error conditions
   - Test integration between related functions
   - Use descriptive test names: `should calculate reading speed correctly`

4. **What to Test**:
   - ‚úÖ All utility functions in `apps/web/src/utils/`
   - ‚úÖ All Zustand stores in `apps/web/src/stores/`
   - ‚úÖ SRS algorithm implementation
   - ‚úÖ Reading progress calculations
   - ‚úÖ Complex hooks with business logic
   - ‚úÖ API endpoints and validation logic
   - ‚úÖ Data transformation and filtering functions
   - ‚ö†Ô∏è Complex components (when feasible without excessive mocking)

5. **What NOT to Test**:
   - ‚ùå Third-party library internals (React Query, MUI, etc.)
   - ‚ùå Simple pass-through components with no logic
   - ‚ùå Type definitions alone (TypeScript handles this)

#### Test File Organization

- Place tests next to source files: `utils/srs.ts` ‚Üí `utils/srs.test.ts`
- Export types and functions needed for testing
- Use `describe` blocks to group related tests
- Use `beforeEach` to reset state between tests

#### Pre-Commit Checklist

Before committing any code:

1. ‚úÖ All new functions have tests
2. ‚úÖ Run `pnpm vitest run` - all tests pass
3. ‚úÖ Run `pnpm typecheck` - no type errors
4. ‚úÖ Run `pnpm lint` - no linting errors
5. ‚úÖ Manually verify feature works in browser/API
6. ‚úÖ Update `PROGRESS.md` with completed work

### Git & Commits

1. Pre-commit hook runs: lint, format check, typecheck
2. No `console.log` statements allowed in commits
3. Use conventional commits: `feat:`, `fix:`, `chore:`, etc.
4. Keep PRs small and focused

#### CRITICAL: Commit Validation Rules

**NEVER use `--no-verify` to bypass pre-commit hooks unless explicitly instructed by the user.**

When a commit fails due to pre-commit hooks, you MUST:

1. **Fix all errors before attempting to commit again**:
   - ‚ùå **NEVER** use `git commit --no-verify` to bypass checks
   - ‚ùå **NEVER** disable or skip pre-commit hooks
   - ‚ùå **NEVER** commit with failing tests, lint errors, or type errors
   - ‚úÖ Investigate and fix the root cause of each error
   - ‚úÖ Re-run the commit only after all issues are resolved

2. **Error Resolution Priority**:
   - **Type errors**: Fix TypeScript errors in the code (run `pnpm typecheck` to verify)
   - **Lint errors**: Fix ESLint errors (run `pnpm lint` to verify)
   - **Test failures**: Fix failing tests (run `pnpm vitest run` to verify)
   - **Format issues**: Run `pnpm format` to auto-fix formatting

3. **If errors seem unrelated to your changes**:
   - Still fix them before committing
   - If the errors are in files you didn't modify, fix them anyway or notify the user
   - Pre-existing errors in the codebase should be fixed, not bypassed

4. **Only bypass hooks when explicitly told**:
   - The user must explicitly say "use --no-verify" or "skip pre-commit hooks"
   - Document why the bypass was necessary in the commit message
   - This should be extremely rare and only for exceptional circumstances

## File Naming Conventions

- Components: `PascalCase.tsx` (e.g., `ReaderView.tsx`)
- Component Folders: `camelCase/` for feature-specific components (e.g., `components/reader/`)
- Hooks: `camelCase.ts` with `use` prefix (e.g., `useReadingProgress.ts`)
- Utilities: `camelCase.ts` (e.g., `srsAlgorithm.ts`)
- Types: `camelCase.ts` or co-located in `.types.ts`
- Tests: `*.test.ts` or `*.spec.ts`
- Index files: Always include `index.ts` for clean exports from folders

## Documentation

### Core Documents (Root Directory)

- **[docs/SPECIFICATIONS.md](docs/SPECIFICATIONS.md)** - Product requirements and feature specifications
- **[PROGRESS.md](PROGRESS.md)** - Comprehensive progress tracking (update as you work)
- **[README.md](README.md)** - Project overview and getting started guide
- **[CLAUDE.md](CLAUDE.md)** - Detailed coding standards for AI assistants

### Before Starting Work

1. Review [PROGRESS.md](PROGRESS.md) for feature status
2. Review [docs/SPECIFICATIONS.md](docs/SPECIFICATIONS.md) for feature requirements
3. Check [CLAUDE.md](CLAUDE.md) for detailed coding standards
4. Reference the database schema in SPECIFICATIONS.md for data models

### After Completing Work

1. Ensure all tests pass (`pnpm vitest run`)
2. Verify linting and type checking pass
3. Test the feature manually
4. Update `PROGRESS.md` with completed work
5. Suggest new work in `PROGRESS.md` including high-impact, high-value features, and test coverage